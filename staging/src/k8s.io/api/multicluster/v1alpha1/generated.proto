/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = 'proto2';

package k8s.io.api.multicluster.v1alpha1;

import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/schema/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "v1alpha1";

// ClusterSpec contains service configuration mapped to a specific cluster
message ClusterSpec {
  optional string cluster = 1;

  // +listType=atomic
  // +optional
  repeated string topologyKeys = 2;

  // +optional
  optional bool publishNotReadyAddresses = 3;

  // +optional
  optional string sessionAffinity = 4;

  // +optional
  optional k8s.io.api.core.v1.SessionAffinityConfig sessionAffinityConfig = 5;
}

// ServiceExport declares that the associated service should be exported to
// other clusters.
message ServiceExport {
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  // +optional
  optional ServiceExportStatus status = 2;
}

// ServiceExportCondition contains details for the current condition of this
// service export.
//
// Once [#1624](https://github.com/kubernetes/enhancements/pull/1624) is
// merged, this will be replaced by metav1.Condition.
message ServiceExportCondition {
  optional string type = 1;

  // Status is one of {"True", "False", "Unknown"}
  optional string status = 2;

  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

  // +optional
  optional string reason = 4;

  // +optional
  optional string message = 5;
}

// ServiceExportList represents a list of endpoint slices
message ServiceExportList {
  // Standard list metadata.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  // List of endpoint slices
  // +listType=set
  repeated ServiceExport items = 2;
}

// ServiceExportStatus contains the current status of an export.
message ServiceExportStatus {
  // +optional
  // +patchStrategy=merge
  // +patchMergeKey=type
  // +listType=map
  // +listMapKey=type
  repeated ServiceExportCondition conditions = 1;
}

// ServiceImport declares that the specified service should be exported to other clusters.
message ServiceImport {
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  // +optional
  optional ServiceImportSpec spec = 2;
}

// ServiceImportList represents a list of endpoint slices
message ServiceImportList {
  // Standard list metadata.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  // List of endpoint slices
  // +listType=set
  repeated ServiceImport items = 2;
}

// ServiceImportSpec contains the current status of an imported service and the
// information necessary to consume it
message ServiceImportSpec {
  // +patchMergeKey=port
  // +patchStrategy=merge
  // +listType=map
  // +listMapKey=port
  // +listMapKey=protocol
  repeated k8s.io.api.core.v1.ServicePort ports = 1;

  // +optional
  // +patchStrategy=merge
  // +patchMergeKey=cluster
  // +listType=map
  // +listMapKey=cluster
  repeated ClusterSpec clusters = 2;

  // +optional
  optional string ipFamily = 3;

  // +optional
  optional string IP = 4;
}

